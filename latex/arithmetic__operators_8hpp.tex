\hypertarget{arithmetic__operators_8hpp}{}\doxysection{include/experimental/linear\+\_\+algebra/arithmetic\+\_\+operators.hpp File Reference}
\label{arithmetic__operators_8hpp}\index{include/experimental/linear\_algebra/arithmetic\_operators.hpp@{include/experimental/linear\_algebra/arithmetic\_operators.hpp}}
{\ttfamily \#include $<$experimental/linear\+\_\+algebra.\+hpp$>$}\newline
Include dependency graph for arithmetic\+\_\+operators.\+hpp\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{arithmetic__operators_8hpp__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{arithmetic__operators_8hpp__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacestd}{std}}
\item 
namespace \mbox{\hyperlink{namespacestd_1_1math}{std\+::math}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a96d6d345149ee19d394bbb50cb832640}{std\+::math\+::operator-\/}} (const T \&t) noexcept(noexcept(operations\+::template negation$<$ T $>$\+::negate(t)))
\item 
{\footnotesize template$<$class M , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::matrix\+\_\+data\+\_\+v$<$\+M$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_ae82a9727c2ed37e6d54c26d97cb1ca7e}{std\+::math\+::trans}} (const M \&m) noexcept(noexcept(operations\+::template transpose\+\_\+matrix$<$ M $>$\+::trans(m)))
\item 
{\footnotesize template$<$class V , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::vector\+\_\+data\+\_\+v$<$\+V$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_ac5098ff00eb6cf1baa08bb550b8d0013}{std\+::math\+::trans}} (const V \&v) noexcept(noexcept(operations\+::template transpose\+\_\+vector$<$ V $>$\+::trans(v)))
\item 
{\footnotesize template$<$class M , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::matrix\+\_\+data\+\_\+v$<$\+M$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a5de07ffd7ce1b2a4b5264b7754522b1b}{std\+::math\+::conj}} (const M \&m) noexcept(noexcept(operations\+::template conjugate\+\_\+matrix$<$ M $>$\+::conjugate(m)))
\item 
{\footnotesize template$<$class V , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::vector\+\_\+data\+\_\+v$<$\+V$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_af9810b3eb460f0927294422090884e43}{std\+::math\+::conj}} (const V \&v) noexcept(noexcept(operations\+::template conjugate\+\_\+vector$<$ V $>$\+::conjugate(v)))
\item 
{\footnotesize template$<$class T1 , class T2 , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T1$>$ \&\& concepts\+::tensor\+\_\+data\+\_\+v$<$\+T2$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_acf454a5786b787e1b3eb09bcdf29c9aa}{std\+::math\+::operator+}} (const T1 \&t1, const T2 \&t2) noexcept(noexcept(operations\+::template addition$<$ T1, T2 $>$\+::add(t1, t2)))
\item 
{\footnotesize template$<$class T1 , class T2 , typename  = enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T1$>$ \&\&                                   concepts\+::tensor\+\_\+data\+\_\+v$<$\+T2$>$ \&\&                                   \+::std\+::is\+\_\+convertible\+\_\+v$<$ decltype( declval$<$typename T1\+::value\+\_\+type$>$() + declval$<$typename T2\+::value\+\_\+type$>$() ), typename T1\+::element\+\_\+type $>$$>$ }\\constexpr T1 \& \mbox{\hyperlink{namespacestd_1_1math_ae293f2c25475f1ba04aca68da7fd2a79}{std\+::math\+::operator+=}} (T1 \&t1, const T2 \&t2) noexcept(noexcept(operations\+::template addition$<$ T1, T2 $>$\+::add(t1, t2)))
\item 
{\footnotesize template$<$class T1 , class T2 , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T1$>$ \&\& concepts\+::tensor\+\_\+data\+\_\+v$<$\+T2$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a09b2165f2c3bffeb9b293edca35f0b2e}{std\+::math\+::operator-\/}} (const T1 \&t1, const T2 \&t2) noexcept(noexcept(operations\+::template subtraction$<$ T1, T2 $>$\+::subtract(t1, t2)))
\item 
{\footnotesize template$<$class T1 , class T2 , typename  = enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T1$>$ \&\&                                   concepts\+::tensor\+\_\+data\+\_\+v$<$\+T2$>$ \&\&                                   \+::std\+::is\+\_\+convertible\+\_\+v$<$ decltype( declval$<$typename T1\+::value\+\_\+type$>$() -\/ declval$<$typename T2\+::value\+\_\+type$>$() ), typename T1\+::element\+\_\+type $>$$>$ }\\constexpr T1 \& \mbox{\hyperlink{namespacestd_1_1math_a4f6e8272ffda073ed7e3ab8ece790990}{std\+::math\+::operator-\/=}} (T1 \&t1, const T2 \&t2) noexcept(noexcept(operations\+::template subtraction$<$ T1, T2 $>$\+::subtract(t1, t2)))
\item 
{\footnotesize template$<$class S , class T , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T$>$ \&\&                                          !concepts\+::tensor\+\_\+data\+\_\+v$<$\+S$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::product\+\_\+exists\+\_\+v$<$ typename T\+::value\+\_\+type, S $>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_aaaba9e144f3b3f40d947b5482b885b5d}{std\+::math\+::operator$\ast$}} (const S \&s, const T \&t) noexcept(noexcept(operations\+::template scalar\+\_\+product$<$ S, T $>$\+::prod(s, t)))
\item 
{\footnotesize template$<$class T , class S , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T$>$ \&\&                                          !concepts\+::tensor\+\_\+data\+\_\+v$<$\+S$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::product\+\_\+exists\+\_\+v$<$ typename T\+::value\+\_\+type, S $>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a262dff53ea621a086935aea94bd6a64d}{std\+::math\+::operator$\ast$}} (const T \&t, const S \&s) noexcept(noexcept(operations\+::template scalar\+\_\+product$<$ S, T $>$\+::prod(t, s)))
\item 
{\footnotesize template$<$class T , class S , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T$>$ \&\&                                          !concepts\+::tensor\+\_\+data\+\_\+v$<$\+S$>$ \&\&                                          concepts\+::product\+\_\+exists\+\_\+v$<$ typename T\+::value\+\_\+type, S $>$ \&\&                                          \+::std\+::is\+\_\+convertible\+\_\+v$<$ decltype( declval$<$typename T\+::value\+\_\+type$>$() $\ast$ declval$<$\+S$>$() ), typename T\+::element\+\_\+type $>$$>$ }\\constexpr T \& \mbox{\hyperlink{namespacestd_1_1math_a8ce5946ea5a3d9b7a65fe914fbd107bc}{std\+::math\+::operator$\ast$=}} (T \&t, const S \&s) noexcept(noexcept(operations\+::template scalar\+\_\+product$<$ S, T $>$\+::prod(t, s)))
\item 
{\footnotesize template$<$class T , class S , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T$>$ \&\&                                          concepts\+::division\+\_\+exists\+\_\+v$<$ typename T\+::value\+\_\+type, S $>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a6d48c8c6cbe3f05f3dbced6efb3d2bb4}{std\+::math\+::operator/}} (const T \&t, const S \&s) noexcept(noexcept(operations\+::template scalar\+\_\+division$<$ T, S $>$\+::divide(t, s)))
\item 
{\footnotesize template$<$class T , class S , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::tensor\+\_\+data\+\_\+v$<$\+T$>$ \&\&                                          concepts\+::division\+\_\+exists\+\_\+v$<$ typename T\+::value\+\_\+type, S $>$ \&\&                                          \+::std\+::is\+\_\+convertible\+\_\+v$<$ decltype( declval$<$typename T\+::value\+\_\+type$>$() $\ast$ declval$<$\+S$>$() ), typename T\+::element\+\_\+type $>$$>$ }\\constexpr T \& \mbox{\hyperlink{namespacestd_1_1math_aa5687dfeb751c189d8dffaff793ef5b5}{std\+::math\+::operator/=}} (T \&t, const S \&s) noexcept(noexcept(operations\+::template scalar\+\_\+division$<$ T, S $>$\+::divide(t, s)))
\item 
{\footnotesize template$<$class V1 , class V2 , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::vector\+\_\+data\+\_\+v$<$\+V1$>$ \&\& concepts\+::vector\+\_\+data\+\_\+v$<$\+V2$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a8197d469913a3e9264f768a8fb234008}{std\+::math\+::inner\+\_\+prod}} (const V1 \&v1, const V2 \&v2) noexcept(noexcept(operations\+::template inner\+\_\+product$<$ V1, V2 $>$\+::prod(v1, v2)))
\item 
{\footnotesize template$<$class V1 , class V2 , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::vector\+\_\+data\+\_\+v$<$\+V1$>$ \&\& concepts\+::vector\+\_\+data\+\_\+v$<$\+V2$>$ $>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_af7a6263c7c6a337e346859602c85b7c1}{std\+::math\+::outer\+\_\+prod}} (const V1 \&v1, const V2 \&v2) noexcept(noexcept(operations\+::template outer\+\_\+product$<$ V1, V2 $>$\+::prod(v1, v2)))
\item 
{\footnotesize template$<$class V , class M , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::vector\+\_\+data\+\_\+v$<$\+V$>$ \&\&                                          concepts\+::matrix\+\_\+data\+\_\+v$<$\+M$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a5066264a4625216ddd1e1e269e19d433}{std\+::math\+::operator$\ast$}} (const V \&v, const M \&m) noexcept(noexcept(operations\+::template vector\+\_\+matrix\+\_\+product$<$ V, M $>$\+::prod(v, m)))
\item 
{\footnotesize template$<$class V , class M , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::vector\+\_\+data\+\_\+v$<$\+V$>$ \&\&                                          concepts\+::matrix\+\_\+data\+\_\+v$<$\+M$>$ \&\&                                          detail\+::extents\+\_\+may\+\_\+be\+\_\+equal\+\_\+v$<$ typename V\+::extents\+\_\+type, typename decltype( declval$<$\+V$>$() $\ast$ declval$<$\+M$>$() )\+::extents\+\_\+type $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr V \& \mbox{\hyperlink{namespacestd_1_1math_a230cfbf2dd26d259a2093322b0a07ca6}{std\+::math\+::operator$\ast$=}} (V \&v, const M \&m) noexcept(noexcept(operations\+::template vector\+\_\+matrix\+\_\+product$<$ V, M $>$\+::prod(v, m)))
\item 
{\footnotesize template$<$class M , class V , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::matrix\+\_\+data\+\_\+v$<$\+M$>$ \&\& concepts\+::vector\+\_\+data\+\_\+v$<$\+V$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_acc315759396876f403d1bbe4817b415b}{std\+::math\+::operator$\ast$}} (const M \&m, const V \&v) noexcept(noexcept(operations\+::template vector\+\_\+matrix\+\_\+product$<$ V, M $>$\+::prod(m, v)))
\item 
{\footnotesize template$<$class M1 , class M2 , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::matrix\+\_\+data\+\_\+v$<$\+M1$>$ \&\& concepts\+::matrix\+\_\+data\+\_\+v$<$\+M2$>$ $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr decltype(auto) \mbox{\hyperlink{namespacestd_1_1math_a41e2c24a154bb3c69efed15514f9ddd5}{std\+::math\+::operator$\ast$}} (const M1 \&m1, const M2 \&m2) noexcept(noexcept(operations\+::template matrix\+\_\+matrix\+\_\+product$<$ M1, M2 $>$\+::prod(m1, m2)))
\item 
{\footnotesize template$<$class M1 , class M2 , typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$ concepts\+::matrix\+\_\+data\+\_\+v$<$\+M1$>$ \&\&                                          concepts\+::matrix\+\_\+data\+\_\+v$<$\+M2$>$ \&\&                                          detail\+::extents\+\_\+may\+\_\+be\+\_\+equal\+\_\+v$<$ typename M1\+::extents\+\_\+type, typename decltype( declval$<$\+M1$>$() $\ast$ declval$<$\+M2$>$() )\+::extents\+\_\+type $>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$, typename  = \+::std\+::enable\+\_\+if\+\_\+t$<$true$>$$>$ }\\constexpr M1 \& \mbox{\hyperlink{namespacestd_1_1math_a8d72c69bfb3c993efdf8a93ef92fc0f2}{std\+::math\+::operator$\ast$=}} (M1 \&m1, const M2 \&m2) noexcept(noexcept(operations\+::template matrix\+\_\+matrix\+\_\+product$<$ M1, M2 $>$\+::prod(m1, m2)))
\end{DoxyCompactItemize}
